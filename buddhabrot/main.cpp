//
//  main.cpp
//  buddhabrot
//
//  Created by Keichi Takahashi on 12/03/24.
//  Copyright (c) 2012å¹´ Osaka University. All rights reserved.
//

#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable
#define __CL_ENABLE_EXCEPTIONS

#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <cmath>

#include "cl.hpp"
#include "cl_util.hpp"

#define IMAGE_WIDTH         (800)
#define IMAGE_HEIGHT        (800)
#define BUDDHA_ITERATIONS   (8 * 1024 * 1024)

static float cx_buf[BUDDHA_ITERATIONS];
static float cy_buf[BUDDHA_ITERATIONS];
static unsigned int img_buf[IMAGE_WIDTH * IMAGE_WIDTH];

int main(int argc, const char * argv[])
{
    for (int j = 0; j < BUDDHA_ITERATIONS; j++) {
        cx_buf[j] = (float)rand() / RAND_MAX * 4 - 2;
        cy_buf[j] = (float)rand() / RAND_MAX * 4 - 2;
    }
    
    for (int i = 0; i < IMAGE_WIDTH * IMAGE_HEIGHT; i++) {
        img_buf[i] = 0;
    }
    
    std::vector<cl::Platform> platforms;
    cl::Platform::get(&platforms);
    
    std::cout << platforms.size() << " platforms are found." << std::endl;
    for (int i = 0; i < platforms.size(); ++i) {

        std::string separator(80, '=');
        std::cout << separator << std::endl;
        std::cout << "Platform " << i << ":" << std::endl;
        print_platform_info(platforms[i]);
        
        std::vector<cl::Device> devices;
        platforms[i].getDevices(CL_DEVICE_TYPE_ALL, &devices);
        std::cout << devices.size() << " devices are found." << std::endl;
        for (int j = 0; j < devices.size(); ++j) {
            std::string separator(80, '-');
            std::cout << separator << std::endl;
            std::cout << "Device " << i << ":" << std::endl;
            print_device_info(devices[j]);
        }
    }

    std::vector<cl::Device> devices;
    platforms[0].getDevices(CL_DEVICE_TYPE_ALL, &devices);
    cl::Context::Context context(devices);
    cl::CommandQueue queue(context, devices[0]);
    
    cl::Program program = load_cl_program("OpenCL/kernel.cl.x86_64.bc", context);
    cl::Kernel get_buddhabrot_image(program, "get_buddhabrot_image");
    
    cl::Buffer img(context, CL_MEM_READ_WRITE|CL_MEM_USE_HOST_PTR, IMAGE_WIDTH * IMAGE_WIDTH * sizeof(unsigned int), img_buf);
    cl::Buffer cx(context, CL_MEM_READ_ONLY|CL_MEM_USE_HOST_PTR, BUDDHA_ITERATIONS * sizeof(float), cx_buf);
    cl::Buffer cy(context, CL_MEM_READ_ONLY|CL_MEM_USE_HOST_PTR, BUDDHA_ITERATIONS * sizeof(float), cy_buf);
    get_buddhabrot_image.setArg(0, img);
    get_buddhabrot_image.setArg(1, cx);
    get_buddhabrot_image.setArg(2, cy);
    get_buddhabrot_image.setArg(3, IMAGE_WIDTH);
    get_buddhabrot_image.setArg(4, IMAGE_HEIGHT);
    
    queue.enqueueNDRangeKernel(get_buddhabrot_image, cl::NullRange, cl::NDRange(BUDDHA_ITERATIONS), cl::NullRange);
    queue.enqueueReadBuffer(img, CL_TRUE, 0, IMAGE_WIDTH * IMAGE_WIDTH * sizeof(unsigned int), img_buf);
    
    std::ofstream ofs("/Users/Keichi/Desktop/mandelbrot.ppm");
    ofs << "P3" << std::endl;
    ofs << "#Generated by mandelbrot renderer" << std::endl;
    ofs << IMAGE_WIDTH << " " << IMAGE_HEIGHT<< std::endl;
    ofs << "255" << std::endl;
    
    int max = 0;
    for (int i = 0; i < IMAGE_WIDTH * IMAGE_HEIGHT; i++) {
        if (max < img_buf[i]) {
            max = img_buf[i];
        }
    }
    std::cout << max << std::endl;

    for (int i = 0; i < IMAGE_WIDTH * IMAGE_HEIGHT; i++) {
        float color = (float)img_buf[i] / max;
        color *= exp(1.0);
        color /= 1 + color;
        int val = (int)(color * 255);

        ofs << val << " " << val << " " << val << std::endl;
    }
    ofs.close();
    
    return 0;
}

